---
format:
  revealjs:
    slide-number: true
    fig-width: 6
    fig-asp: 0.618
css: "../slides_quarto.css"
standalone: false
include-in-header: "../header_quarto.html"
logo: "../DSApps_logo_white.jpg"
pagetitle: "Time Series Intro"
callout-appearance: simple
smaller: true
knitr:
  opts_chunk:
    fig-width: 6
    fig-asp: 0.618
execute:
  echo: true
code-line-numbers: false
code-block-border-left: true
highlight-style: github
footer: "[Applications of Data Science](https://dsapps-2023.github.io/Class_Slides/){target='_blank'}"
---

## {.logo-slide}

## Time Series Intro {.title-slide}

### Applications of Data Science - Class 20

### Giora Simchoni

#### `gsimchoni@gmail.com` and add `#dsapps` in subject

### Stat. and OR Department, TAU
### `r Sys.Date()`

---

### What is a Time Series?

A time series is a sequence of observations taken sequentially in time.

```{r}
#| label: Calves
#| echo: true
#| code-fold: true
#| warning: false

library(tidyverse)
library(tsibble)
library(tsibbledata)
library(feasts)

aus_livestock |>
  filter(Animal == "Calves") |>
  index_by() |>
  summarise(Count = sum(Count)) |>
  autoplot(log(Count)) +
  labs(x = "", y = "log no. of calves slaughtered in Australia") +
  scale_x_yearmonth(date_breaks = "5 year", date_labels = "%Y") +
  theme_light()
```

---

### TSA Focuses on:

::::: {.columns}
:::: {.column width="40%"}
::: {.incremental}
- Discrete measurements
- Equally-spaced
- Usually no missing values
- Not that short (say > 20? 50?)
- Time is intrinsic, it is not just another feature
- Could involve time-varying/non-time-varying explaining features
:::
:::
:::: {.column width="60%"}
::: {.fragment}
E.g. this is more of a longitudinal/growth-curve/cohort dataset:

```{r}
#| label: UKB-SBP
#| echo: false
#| warning: false
#| message: false

ukb <- read_csv("~/ukb_sbp_longitudinal.csv")
ggplot(ukb |> sample_n(50000),
       aes(age, sbp, group = factor(id))) +
  geom_line() +
  labs(x = "Age", y = "UK Biobank participants systolic blood pressure") +
  theme_light()
```
:::
::::
:::::

---

### TSA Goals

- Forecasting [(prediction)]{style="font-size:16px"}
- Describing the TS dynamics
- Determination of input features contribution
- Planning: control schemes, intervention analyses, sensitivity analyses
- Multivariate TS: interrelationships, clustering

---

## Detour: Dates in R {.title-slide}

---

#### The `Date` class

```{r}
date_obj <- as.Date("1915-6-16")

class(date_obj)
```

Internally, `Date` objects are stored as the number of days since January 1, 1970, using negative numbers for earlier dates.

```{r}
typeof(date_obj)
as.numeric(date_obj)
```

So this naturally works:

```{r}
date_obj + 10
range(date_obj + 0:10)
```

Can also accept different formats and has a few built-in functions:

```{r}
date_obj <- as.Date("1/15/2001",format="%m/%d/%Y")
months(date_obj)
```

---

#### The `POSIX` classes

`POSIX` is a slightly more evolved class from UNIX, holding number of seconds since January 1, 1970, and a time zone may be specified:

```{r}
now <- Sys.time()

now

class(now)

as.numeric(now)
```

The `POSIXlt` class will store time in a list with useful elements:

```{r}
now <- as.POSIXlt(now, tz = "GMT")
now$hour
```

---

#### The `lubridate` package

Parsing dates:

```{r}
today()

ymd("2023-01-31")

dmy("31-Jan-2023")

ymd(20170131)
```

Making dates:

```{r}
make_date(year = 2013, month = 2, day = 12)
```

Converting between formats:

```{r}
as_datetime(today())
```

---

Getting components:

```{r}
datetime <- ymd_hms("2016-07-08 12:34:56")

year(datetime)
mday(datetime)
yday(datetime)
wday(datetime)
```

Duration, time maths:

```{r}
today() - ymd("2020-01-01") #base R difftime object
as.duration(today() - ymd("2020-01-01"))
today() - dyears(1)
today() + ddays(10)
```

---

## The Tidyverts {.title-slide}

---

### The Tidyverts

A suite of packages for TSA, the **tidy** way, led by [Rob J. Hyndman](https://robjhyndman.com/):

- `tsibble`: The ~~`data.frame`~~ `tibble` re-imagined for temporal data
- `tsibbledata`: TS datasets
- `feasts`: Feature extraction for TS + Some useful `gg` plots
- `fable` and `fabletools`: **The** modeling and forecasting package
- more and more to come.

See [tidyverts.org](https://tidyverts.org/).

---

### `tsibble`

Need a time `index`:

```{r}
library(tsibble)

tsibble(
  date = as.Date("2017-01-01") + 0:9,
  value = rnorm(10)
)
```

Here, as `date` is the only **`Date`** column, `tsibble` gets this.

`[1D]` is the tsibble's `interval`.

---

Grouping variable(s) are specified with `key`:

```{r}
tsibble(
  qtr = rep(yearquarter("2010 Q1") + 0:9, 3),
  group = rep(c("x", "y", "z"), each = 10),
  value = rnorm(30),
  key = group
)
```

---

Here there are 54 TS combinations:

```{r}
aus_livestock
```

---

Wrangling similar to the Tidyverse, only `group_by() + summarise()` on a time index would be `index_by()` + `summarise()`:

```{r}
aus_calves <- aus_livestock |>
  filter(Animal == "Calves") |>
  index_by() |>
  summarise(count = sum(Count), log_count = log(count))

aus_calves
```

---

### `feasts`

Seamless integration with `ggplot2` and friends, use `autoplot()` from `feasts`:

```{r}
#| label: Calves-autoplot
#| code-line-numbers: "|2"

aus_calves |>
  autoplot(log_count) +
  labs(x = "", y = "log no. of calves slaughtered in Australia") +
  scale_x_yearmonth(date_breaks = "5 year", date_labels = "%Y") +
  theme_light()
```

---

Some more useful plots:

```{r}
#| label: Calves-season
#| code-line-numbers: "4"

library(feasts)

aus_calves |>
  gg_season(log_count) +
  labs(x = "", y = "log no. of calves slaughtered in Australia") +
  theme_light()
```

---

```{r}
#| label: Calves-subseries
#| code-line-numbers: "2"

aus_calves |>
  gg_subseries(log_count) +
  labs(x = "", y = "log no. of calves slaughtered in Australia") +
  scale_x_yearmonth(labels = NULL) +
  theme_light()
```

---

```{r}
#| label: Calves-lag
#| code-line-numbers: "2"

aus_calves |>
  gg_lag(log_count, geom = "point") +
  labs(x = "lag(log(count))", y = "log no. of calves slaughtered in Australia") +
  scale_x_yearmonth(labels = NULL) +
  theme_light()
```

---

Some useful features for multiple series:

```{r}
#| label: feasts-features

aus_livestock |>
  features(log(Count), quantile)
```

---

```{r}
#| label: feasts-stl
#| code-line-numbers: "1-3|4|5"

aus_livestock |>
  group_by(Animal) |>
  summarise(total_count = sum(Count)) |>
  features(log(total_count), feat_stl) |>
  select(Animal, trend_strength, spikiness, linearity)
```

---

## TS EDA & Decomposition {.title-slide}

---

### Transformations

:::: {.columns}
::: {.column}
```{r}
#| label: Calves-log
#| echo: false

aus_calves |>
  autoplot(log_count) +
  labs(x = "", y = "log no. of calves slaughtered in Australia") +
  scale_x_yearmonth(date_breaks = "5 year", date_labels = "%Y") +
  theme_light()
```
:::

::: {.column}
```{r}
#| label: Calves-nolog
#| echo: false

aus_calves |>
  autoplot(count) +
  labs(x = "", y = "no. of calves slaughtered in Australia") +
  scale_x_yearmonth(date_breaks = "5 year", date_labels = "%Y") +
  theme_light()
```
:::

::::

::: {.callout-tip}
Why did we need log? What would occur without it?
:::

::: {.callout-tip}
What other transformations are worth considering? Hint: "total monthly sales"
:::

::: {.callout-tip}
What is the 1st conclusion about no. of calves slaughtered in AUS? What is the 2nd?
:::

---

### Classical Decomposition

$$
y_t = S_t + T_t + R_t
$$

where $S_t$ is the seasonal component, $T_t$ is the trend, $R_t$ is the remainder, all at time $t$.

Necessary but not sufficient condition: Make $R_t$ "white noise", i.e. $R_t \sim \mathcal{N}(0, \sigma^2)$

Decomposition can also be multiplicative:

$$
y_t = S_t \times T_t \times R_t
$$

But then we'd take $\log(y_t)$.

---

Make a long story short:

```{r}
#| label: classic-decomp

aus_calves |>
  model(classical_decomposition(log_count)) |>
  components() |>
  autoplot() +
  labs(x = "", y = "log no. of calves slaughtered in Australia") +
  scale_x_yearmonth(date_breaks = "5 year", date_labels = "%Y") +
  theme_light()
```

