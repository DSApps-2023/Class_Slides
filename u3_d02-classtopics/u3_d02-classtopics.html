<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Topics in Classification</title>
    <meta charset="utf-8" />
    <meta name="author" content="Giora Simchoni" />
    <meta name="date" content="2023-02-23" />
    <script src="u3_d02-classtopics_files/header-attrs-2.20/header-attrs.js"></script>
    <head>
      <link rel="icon" href="../DSApps_logo.jpg" type="image/jpg"> 
      <link rel="shortcut icon" href="../DSApps_logo.jpg" type="image/jpg">
    </head>
    <link rel="stylesheet" href="../slides.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: logo-slide

---

class: title-slide

## Topics in Classification

### Applications of Data Science - Class 13

### Giora Simchoni

#### `gsimchoni@gmail.com and add #dsapps in subject`

### Stat. and OR Department, TAU
### 2023-02-23

---



layout: true

&lt;div class="my-footer"&gt;
  &lt;span&gt;
    &lt;a href="https://dsapps-2023.github.io/Class_Slides/" target="_blank"&gt;Applications of Data Science
    &lt;/a&gt;
  &lt;/span&gt;
&lt;/div&gt;

---



class: section-slide

# Topics in Classification

---

# Life isn't perfect

Let's tackle just a few issues:

- Not enough labelled data and data labeling is expensive
- Imbalanced Classes

---

class: section-slide

# Active Learning

---

### Got Data?




```r
n &lt;- 20
x1 &lt;- rnorm(n, 0, 1); x2 &lt;- rnorm(n, 0, 1)
t &lt;- 2 - 4 * x1 + 3 * x2
y &lt;- rbinom(n, 1, 1 / (1 + exp(-t)))
glm_mod &lt;- glm(y ~ x1 + x2, family = "binomial")
```

&lt;img src="images/AL-LR-Example-1.png" width="50%" /&gt;

---

### Want more?

&gt; The key idea behind *active learning* is that a machine learning algorithm can
achieve greater accuracy with fewer training labels if it is allowed to choose the
data from which it learns. An active learner may pose *queries*, usually in the form
of unlabeled data instances to be labeled by an *oracle* (e.g., a human annotator).
Active learning is well-motivated in many modern machine learning problems,
where unlabeled data may be abundant or easily obtained, but labels are difficult,
time-consuming, or expensive to obtain.

([Settles, 2010](http://burrsettles.com/pub/settles.activelearning.pdf))

&gt; You want data? Well data costs!

(No one, ever)

---

### Where this is going

&lt;img src="images/active_learning_plan.png" style="width: 90%" /&gt;

---

### Active Learning Scenarios

1. **Membership Query Synthesis**: You get to choose which (maybe theoretical) points you'd want `\(y\)` labelled for.
2. **Stream-Based Selective Sampling**: You get 1 point at a time and decide which ones you'd like to query and which to discard.
3. **Pool-Based Sampling**: You have a large collecetion of unlabelled points at your disposal, you need to send the "best ones" for labelling

&lt;img src="images/active_learning_scenarios.png" style="width: 70%" /&gt;

---

### Uncertainty Sampling

.insight[
üí° For a 2-class dataset, the observations your model is most uncertain of are...
]

&lt;img src="images/AL-LR-Example2-1.png" width="50%" /&gt;

---

### Uncertainty Sampling Measures

Let `\(\hat{y}_i\)` be the predicted classes with `\(i\)`th highest score (probability), for observations `\(x\)` under some model `\(\theta\)`.

So `\(\hat{y}_1 = \arg\max{P_{\theta}(y|x)}\)` are the actual predicted classes, `\(\hat{y}_2\)` are the second choices, etc.

* Least Confidence: Choose those observations for which `\(P_{\theta}(\hat{y}_1|x)\)` is smallest:

`\(x^*_{LC} = \arg\min{P_{\theta}(\hat{y}_1|x)}\)`

.insight[
üí° For a 2-class balanced dataset, this means...
]

---

* Margin Sampling: Choose those observations for which the margin between the two highest scores is smallest:

`\(x^*_M = \arg\min{P_{\theta}(\hat{y}_1|x) - P_{\theta}(\hat{y}_2|x)}\)`

.insight[
üí° For a 2-class balanced dataset, this means...
]

* Entropy: Choose the observations for which entropy is highest:

`\(x^*_H = \arg\max-{\sum_i P_{\theta}(\hat{y}_i|x) \log[P_{\theta}(\hat{y}_i|x)]}\)`

We will talk more about entropy in Neural Networks, let's minimize negative entropy.

.insight[
üí° For a 2-class balanced dataset, this means...
]

---

### Example: The `spotify_songs` data from HW3


```r
spotify_songs &lt;- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-01-21/spotify_songs.csv')

spotify_songs %&gt;% count(playlist_genre)
```

```
## # A tibble: 6 √ó 2
##   playlist_genre     n
##   &lt;chr&gt;          &lt;int&gt;
## 1 edm             6043
## 2 latin           5155
## 3 pop             5507
## 4 r&amp;b             5431
## 5 rap             5746
## 6 rock            4951
```

Let's try to classify the genre of a song!

---

We'll take only the 12 audio features as predictors, and choose each `track_id` once (remember each song appears a few times?):


```r
library(tidymodels)

predictors &lt;- 12:23

spotify_songs &lt;- spotify_songs %&gt;%
  group_by(track_id) %&gt;%
  slice_sample(n = 1) %&gt;%
  ungroup() %&gt;%
  distinct(track_name, .keep_all = TRUE) %&gt;%
  select(track_id, track_name, track_artist, playlist_genre, predictors) %&gt;%
  mutate(playlist_genre = recode(playlist_genre, "r&amp;b" = "rnb"))

set.seed(76)
sptfy_split_obj &lt;- spotify_songs %&gt;%
  initial_split(prop = 0.8)
sptfy_tr &lt;- training(sptfy_split_obj)
sptfy_te &lt;- testing(sptfy_split_obj)
```

---

Plot twist! We only have 20 songs from each genre!


```r
set.seed(1)
sptfy_tr_small &lt;- sptfy_tr %&gt;%
  group_by(playlist_genre) %&gt;%
  slice_sample(n = 20) %&gt;%
  ungroup()

sptfy_tr_small %&gt;% count(playlist_genre)
```

```
## # A tibble: 6 √ó 2
##   playlist_genre     n
##   &lt;chr&gt;          &lt;int&gt;
## 1 edm               20
## 2 latin             20
## 3 pop               20
## 4 rap               20
## 5 rnb               20
## 6 rock              20
```

Muhaha!

---

We'll also have a pool of songs to query, `sptfy_tr_large`:


```r
sptfy_tr_large &lt;- sptfy_tr %&gt;%
  anti_join(sptfy_tr_small, by = "track_id")
```

We `bake()` the 3 datasets with the small sample params recipe:


```r
sptfy_rec &lt;- recipe(playlist_genre ~ ., data = sptfy_tr_small) %&gt;%
  update_role(track_id, track_name, track_artist,
              new_role = "id") %&gt;%
  step_normalize(all_numeric(), -has_role("id")) %&gt;%
  step_string2factor(playlist_genre) %&gt;%
  prep(sptfy_tr_small, strings_as_factors = FALSE)

sptfy_tr_small &lt;- juice(sptfy_rec)
sptfy_tr_large &lt;- bake(sptfy_rec, new_data = sptfy_tr_large)
sptfy_te &lt;- bake(sptfy_rec, new_data = sptfy_te)
```

---

Let's build a simple GBT model:


```r
mod_spec &lt;- boost_tree(mode = "classification", trees = 100) %&gt;%
  set_engine("xgboost", eval_metric = "mlogloss")

mod_fit &lt;- mod_spec %&gt;%
  fit(playlist_genre ~ ., data = sptfy_tr_small %&gt;%
        select(-track_id, -track_name, -track_artist))

mod_pred &lt;- mod_fit %&gt;%
  predict(new_data = sptfy_tr_large, type = "prob")

mod_pred
```

```
## # A tibble: 18,640 √ó 6
##    .pred_edm .pred_latin .pred_pop .pred_rap .pred_rnb .pred_rock
##        &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
##  1   0.926      0.00230    0.0625   0.00202   0.000854   0.00590 
##  2   0.00472    0.00170    0.0112   0.000684  0.00106    0.981   
##  3   0.0212     0.613      0.00471  0.300     0.0504     0.00994 
##  4   0.00220    0.000616   0.00261  0.000749  0.993      0.000780
##  5   0.913      0.0296     0.0172   0.0347    0.00192    0.00370 
##  6   0.171      0.237      0.0459   0.514     0.00756    0.0247  
##  7   0.00155    0.00378    0.0154   0.00124   0.970      0.00794 
##  8   0.255      0.351      0.00678  0.270     0.114      0.00356 
##  9   0.00444    0.00184    0.0212   0.000883  0.0409     0.931   
## 10   0.109      0.589      0.125    0.0267    0.118      0.0325  
## # ‚Ä¶ with 18,630 more rows
```

---

Test accuracy?


```r
mod_te_pred_class &lt;- mod_fit %&gt;%
      predict(new_data = sptfy_te) %&gt;%
      bind_cols(sptfy_te)

mod_te_pred_class %&gt;%
  accuracy(truth = playlist_genre, estimate = .pred_class)
```

```
## # A tibble: 1 √ó 3
##   .metric  .estimator .estimate
##   &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt;
## 1 accuracy multiclass     0.363
```




Remember this model was built on 120 of almost 19K available unique songs!

---

Test Recall and Precision:


```r
mod_te_pred_class %&gt;%
  group_by(playlist_genre) %&gt;%
  accuracy(truth = playlist_genre, estimate = .pred_class) %&gt;%
  select(playlist_genre, recall = .estimate) %&gt;%
  bind_cols(
    mod_te_pred_class %&gt;%
      group_by(.pred_class) %&gt;%
      accuracy(truth = playlist_genre, estimate = .pred_class) %&gt;%
      select(precision = .estimate)
  )
```

```
## # A tibble: 6 √ó 3
##   playlist_genre recall precision
##   &lt;fct&gt;           &lt;dbl&gt;     &lt;dbl&gt;
## 1 edm             0.454     0.517
## 2 latin           0.376     0.255
## 3 pop             0.25      0.249
## 4 rap             0.318     0.406
## 5 rnb             0.305     0.312
## 6 rock            0.472     0.487
```

---

Build a function which will take each row of predicted probs and return a list of 3 uncertainty metrics:


```r
uncertainty_lc &lt;- function(probs) {
  max(probs)
}

uncertainty_m &lt;- function(probs) {
  o &lt;- order(probs, decreasing = TRUE)
  probs[o[1]] - probs[o[2]]
}

uncertainty_h &lt;- function(probs) {
  sum(probs * log(probs + 0.000001))
}

uncertainty &lt;- function(...) {
  probs &lt;- c(...)
  list(
    lc = uncertainty_lc(probs),
    margin = uncertainty_m(probs),
    entropy = uncertainty_h(probs)
  )
}
```

---


```r
mod_unc &lt;- mod_pred %&gt;% pmap_dfr(uncertainty)

mod_unc
```

```
## # A tibble: 18,640 √ó 3
##       lc margin entropy
##    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
##  1 0.926 0.864  -0.307 
##  2 0.981 0.969  -0.118 
##  3 0.613 0.313  -0.964 
##  4 0.993 0.990  -0.0514
##  5 0.913 0.878  -0.406 
##  6 0.514 0.278  -1.25  
##  7 0.970 0.955  -0.172 
##  8 0.351 0.0816 -1.37  
##  9 0.931 0.890  -0.321 
## 10 0.589 0.464  -1.27  
## # ‚Ä¶ with 18,630 more rows
```

Obviously these are correlated:

---

.pull-left[


```r
mod_unc %&gt;% slice_sample(n = 1000) %&gt;%
  ggplot(aes(lc, margin)) +
  geom_point() +
  theme_light() +
  theme(text =
          element_text(size = 14))
```

&lt;img src="images/AL-MR-Lc-Margin-1.png" width="100%" /&gt;

]

.pull-right[


```r
mod_unc %&gt;% slice_sample(n = 1000) %&gt;%
  ggplot(aes(lc, entropy)) +
  geom_point() +
  theme_light() +
  theme(text =
          element_text(size = 14))
```

&lt;img src="images/AL-MR-Lc-Entropy-1.png" width="100%" /&gt;

]

---

Which are the top 10 songs in terms of each metric the model is most curious about?


```r
sptfy_tr_large_with_unc &lt;- sptfy_tr_large %&gt;%
  bind_cols(mod_unc) %&gt;%
  select(track_name, track_artist, playlist_genre, lc, margin, entropy)

sptfy_tr_large_with_unc %&gt;%
  slice_min(lc, n = 10) %&gt;%
  arrange(lc, track_name)
```

```
## # A tibble: 10 √ó 6
##    track_name                  track_artist playlist_genre    lc  margin entropy
##    &lt;chr&gt;                       &lt;chr&gt;        &lt;fct&gt;          &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
##  1 Deja                        Ali Aka Mind rap            0.205 5.76e-4   -1.72
##  2 Bag In Da Box (feat. Orrem‚Ä¶ DJ Tune      edm            0.211 2.60e-5   -1.74
##  3 Return of the Mack - C&amp;J E‚Ä¶ Mark Morris‚Ä¶ rnb            0.216 3.52e-2   -1.78
##  4 Mad Money                   Dave Nazza   edm            0.227 1.15e-2   -1.64
##  5 Banda De Cami√≥n (Remix) [f‚Ä¶ El Alfa      latin          0.229 3.24e-2   -1.74
##  6 Told You So                 T.I.         rap            0.232 1.88e-3   -1.67
##  7 American Boyfriend          Kevin Abstr‚Ä¶ rnb            0.234 7.52e-4   -1.73
##  8 Neptune                     EDX          edm            0.235 1.62e-2   -1.67
##  9 DJ No Pare (feat. Zion, Da‚Ä¶ Justin Quil‚Ä¶ latin          0.238 1.09e-2   -1.72
## 10 tonite                      LCD Soundsy‚Ä¶ pop            0.239 6.48e-3   -1.68
```

---


```r
sptfy_tr_large_with_unc %&gt;%
  slice_min(margin, n = 10) %&gt;%
  arrange(margin, track_name)
```

```
## # A tibble: 10 √ó 6
##    track_name                  track_artist playlist_genre    lc  margin entropy
##    &lt;chr&gt;                       &lt;chr&gt;        &lt;fct&gt;          &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
##  1 Bag In Da Box (feat. Orrem‚Ä¶ DJ Tune      edm            0.211 2.60e-5  -1.74 
##  2 Right Now (feat. Future, F‚Ä¶ Uncle Murda  rap            0.343 9.22e-5  -1.17 
##  3 Traidora                    Gente De Zo‚Ä¶ latin          0.315 9.25e-5  -1.40 
##  4 Dancing In the Dark         Bruce Sprin‚Ä¶ rock           0.290 1.04e-4  -1.52 
##  5 The Kids Are Coming         Tones and I  pop            0.330 1.21e-4  -1.40 
##  6 Legacy - Radio Edit         Nicky Romero edm            0.495 1.73e-4  -0.760
##  7 Cause We Can                SMO          rap            0.288 2.09e-4  -1.61 
##  8 My Feelings                 DiRTY RADiO  pop            0.389 2.80e-4  -1.24 
##  9 what you doin'              Masked Man   rap            0.315 2.84e-4  -1.36 
## 10 –ë—ã–ª —Ö—É–ª–∏–≥–∞–Ω–æ–º               StaFFord63   rap            0.424 2.95e-4  -1.16
```

---


```r
sptfy_tr_large_with_unc %&gt;%
  slice_min(entropy, n = 10) %&gt;%
  arrange(entropy, track_name)
```

```
## # A tibble: 10 √ó 6
##    track_name                  track_artist playlist_genre    lc  margin entropy
##    &lt;chr&gt;                       &lt;chr&gt;        &lt;fct&gt;          &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
##  1 Return of the Mack - C&amp;J E‚Ä¶ Mark Morris‚Ä¶ rnb            0.216 3.52e-2   -1.78
##  2 Want Her                    Mustard      rap            0.263 7.40e-2   -1.75
##  3 When We Face Reality - Khe‚Ä¶ Sahar Z      edm            0.258 6.26e-2   -1.74
##  4 Bag In Da Box (feat. Orrem‚Ä¶ DJ Tune      edm            0.211 2.60e-5   -1.74
##  5 Banda De Cami√≥n (Remix) [f‚Ä¶ El Alfa      latin          0.229 3.24e-2   -1.74
##  6 En Su Nota                  Don Omar     latin          0.275 8.87e-2   -1.74
##  7 Isn't It Time               The Babys    rock           0.283 9.48e-2   -1.74
##  8 original me (feat. dan rey‚Ä¶ YUNGBLUD     rock           0.248 3.36e-2   -1.73
##  9 Fall in Love                GoldLink     rnb            0.259 3.26e-2   -1.73
## 10 American Boyfriend          Kevin Abstr‚Ä¶ rnb            0.234 7.52e-4   -1.73
```

---

So far it's only interesting. Will sending the observations our model is most curious about to the "oracle" prove to increase test accuracy better than random observations? See full code in slides Rmd files.





&lt;img src="images/Simul-Unc-1.png" width="100%" /&gt;

---

### Query by Commity (QBC)

Similar to ensemble models, we have a committee of models:

`\(C = \{\theta_1, ..., \theta_C\}\)`

Which observations the commitee is most uncertain of? E.g.

`\(x^*_{VE} = \arg\max-{\sum_i \frac{V(\hat{y}_i|x)}{|C|}\log{\frac{V(\hat{y}_i|x)}{|C|}}}\)`

Where `\(V(\hat{y}_i|x)\)` is the number of votes for `\(\hat{y}_i\)`.

How do you get a committee?
- Different models
- Bagging
- Same model, different subsets of features
- Same model, different params

---

Let's do 6 GBT models, each receiving 2 different consecutive features:


```r
fit_sub_model &lt;- function(i, tr, te) {
  mod_fit &lt;- mod_spec %&gt;%
    fit(playlist_genre ~ ., data = tr %&gt;%
          select(playlist_genre, (2 + i * 2):(3 + i * 2)))

  mod_fit %&gt;%
    predict(new_data = te)
}
mod_pred &lt;- map_dfc(1:6, fit_sub_model,
                    tr = sptfy_tr_small, te = sptfy_tr_large)
mod_pred
```

```
## # A tibble: 18,640 √ó 6
##    .pred_class...1 .pred_class...2 .pred_class...3 .pred_class...4
##    &lt;fct&gt;           &lt;fct&gt;           &lt;fct&gt;           &lt;fct&gt;          
##  1 edm             edm             latin           pop            
##  2 edm             pop             rnb             edm            
##  3 latin           rnb             edm             latin          
##  4 rnb             rnb             rock            rap            
##  5 rnb             rock            rap             latin          
##  6 rnb             rock            rap             edm            
##  7 rnb             rap             rock            rap            
##  8 rap             rnb             rap             rnb            
##  9 edm             latin           latin           rock           
## 10 pop             edm             edm             latin          
## # ‚Ä¶ with 18,630 more rows, and 2 more variables: .pred_class...5 &lt;fct&gt;,
## #   .pred_class...6 &lt;fct&gt;
```

---


```r
mod_qbc &lt;- mod_pred %&gt;%
  mutate(probs = pmap(
    select(., starts_with(".pred")),
    function(...) table(c(...)) / 6),
    vote_entropy = map_dbl(probs, uncertainty_h),
    vote_margin = map_dbl(probs, uncertainty_m))

sptfy_tr_large_with_qbc &lt;- sptfy_tr_large %&gt;%
  bind_cols(mod_qbc) %&gt;%
  select(track_name, track_artist, playlist_genre,
         starts_with(".pred"), vote_entropy)

sptfy_tr_large_with_qbc %&gt;%
  slice_min(vote_entropy, n = 10) %&gt;%
  arrange(vote_entropy) %&gt;%
  select(starts_with(".pred"))
```

```
## # A tibble: 214 √ó 6
##    .pred_class...17 .pred_class...18 .pred_class...19 .pred_class...20
##    &lt;fct&gt;            &lt;fct&gt;            &lt;fct&gt;            &lt;fct&gt;           
##  1 edm              rap              rnb              rock            
##  2 rap              rnb              latin            pop             
##  3 rock             latin            rnb              edm             
##  4 rnb              latin            rap              edm             
##  5 rock             rnb              edm              rap             
##  6 edm              rap              rock             latin           
##  7 rnb              edm              rap              rock            
##  8 rock             pop              edm              rnb             
##  9 edm              rnb              pop              rap             
## 10 pop              rock             rnb              edm             
## # ‚Ä¶ with 204 more rows, and 2 more variables: .pred_class...21 &lt;fct&gt;,
## #   .pred_class...22 &lt;fct&gt;
```

---

Will sending the observations our committee is in most disagreement about to the "oracle" prove to increase test accuracy better than random observations? See full code in slides Rmd files.





&lt;img src="images/Simul-QBC-1.png" width="100%" /&gt;

---

### Other Active Learning Metrics

- Expected Model Change
- Expected Error Reduction
- Variance Reduction
- And more...

---

class: section-slide

# Imbalanced Classes

---

### Typical examples of Imbalanced Classes scenarios

- Rare diseases: [this](https://www.kaggle.com/c/hivprogression) dataset contains genetic data for 1,000 HIV patients, 206 out of 1,000 patients improved after 16 weeks of therapy
- Conversion/Sell/CTR rates: [this](https://www.kaggle.com/c/avazu-ctr-prediction) dataset contains 10 days of Click-Through-Rate data for Avazu mobile ads, ~6.8M clicked out of ~40.4M
- Fraud detection: [this](https://www.kaggle.com/mlg-ulb/creditcardfraud) dataset contains credit card transactions for a major European CC, 492 frauds out of 284,807 transactions

---

### What's so difficult about imbalanced classes?


```r
okcupid_pets &lt;- as_tibble(read_rds("../data/okcupid3_imp_mice.rds"))

idx &lt;- read_rds("../data/okcupid3_idx.rda")
train_idx &lt;- idx$train_idx
valid_idx &lt;- idx$valid_idx
test_idx &lt;- idx$test_idx

ok_train &lt;- okcupid_pets[train_idx, ]
ok_valid &lt;- okcupid_pets[valid_idx, ]

ok_train %&gt;%
  count(pets) %&gt;%
  mutate(pct = round(n / sum(n), 2))
```

```
## # A tibble: 2 √ó 3
##   pets      n   pct
##   &lt;fct&gt; &lt;int&gt; &lt;dbl&gt;
## 1 cats   1624  0.16
## 2 dogs   8376  0.84
```

.insight[
üí° What's a sure way to get 84% accuracy?
]

---




```r
mod_glm &lt;- glm(pets ~ ., data = ok_train, family = "binomial")
pred_glm &lt;- 1 - predict(mod_glm, ok_valid, type = "response")

pred_glm_class &lt;- ifelse(pred_glm &gt; 0.5, "cats", "dogs")
true_class &lt;- ok_valid$pets

table(true_class, pred_glm_class)
```

```
##           pred_glm_class
## true_class cats dogs
##       cats   66  407
##       dogs   62 2194
```

```r
report_accuracy_and_auc(true_class, pred_glm)
```

```
## Setting direction: controls &lt; cases
```

```
## AUC: 0.736
## ACC: 0.828
## Cats: Recall: 0.14
##       Precision: 0.516
## Dogs: Recall: 0.973
##       Precision: 0.844
```

---

### Remedies for Imbalanced Classes

- Model level
  - Tuning parameters and Cutoff choice
  - Cost-aware training: Case weights and Prior probabilities
- Data level
  - Down sampling
  - Up sampling
  - Get more data and features from minority class, similar to Active Learning
- Change of Framework
  - Anomaly Detection
- One final word of wisdom

---

### Tuning parameters and cutoff choice

A general good approach would be:

1. Choose a  model to maximize AUC on one part of the training dataset (using resampling)
2. Choose a cutoff score on another part of the training dataset
3. Fitting the entire thing on all training set and checking on test set

But. You could incorporate your initial goal even into (1), making the cutoff another tuning parameter that would maximize:

- Recall(cats): If never missing a cat person (the minority class) is your job .font80percent[(while maintaining acceptable level of Precision(cats))]
- Precision(cats): If you don't have room for error when you say a person is a cat person .font80percent[(while maintaining acceptable level of Precision(cats))]
- Some other metric like F1-score

---

Let us choose a model by maximizing AUC then present our client with a few potential cutoffs.

We'll begin by splitting our training set into two:


```r
ok_split &lt;- initial_split(ok_train, prop = 0.7, strata = pets)

ok_train1 &lt;- training(ok_split)
ok_train2 &lt;- testing(ok_split)

dim(ok_train1)
```

```
## [1] 6999   38
```

```r
dim(ok_train2)
```

```
## [1] 3001   38
```

---

Use the first training set to choose a GBT model to maximize AUC with 5-fold CV:


```r
mod_gbt_spec &lt;- boost_tree(mode = "classification",
                           mtry = tune(),
                           min_n = tune(),
                           learn_rate = tune(),
                           trees = 1000) %&gt;%
  set_engine("xgboost", eval_metric = "logloss")

gbt_grid &lt;- grid_regular(mtry(range(10, 50)),
                         min_n(range(10, 100)),
                         learn_rate(range(-3, -1)),
                         levels = 3)
rec_gbt &lt;- recipe(pets ~ ., data = ok_train1) %&gt;%
  step_dummy(all_nominal(), -all_outcomes()) %&gt;%
  prep(ok_train1)

cv_splits &lt;- vfold_cv(juice(rec_gbt), v = 5, strata = pets)
```

---


```r
tune_res &lt;- tune_grid(object = mod_gbt_spec,
                      preprocessor = recipe(pets~., data = juice(rec_gbt)),
                      resamples = cv_splits,
                      grid = gbt_grid,
                      control = control_grid(verbose = TRUE),
                      metrics = metric_set(roc_auc))
```

&lt;img src="images/Imbalanced-AUC-Res-1.png" width="100%" /&gt;



---

Fit the best model on all of `ok_train1` and get scores on `ok_train2`:


```r
mod_gbt_spec &lt;- mod_gbt_spec %&gt;%
  update(mtry = 30, trees = 1000,
         min_n = 10, learn_rate = 0.01)
mod_gbt &lt;- mod_gbt_spec %&gt;%
  fit(pets ~ ., data = juice(rec_gbt))

pred_gbt &lt;- mod_gbt %&gt;%
  predict(new_data = bake(rec_gbt, ok_train2), type = "prob") %&gt;%
  pull(.pred_cats)
```

---

You can use the ROC curve to understad the behavior of the cutoff:





&lt;img src="images/Imbalanced-AUC-ROC-1.png" width="60%" /&gt;

---

Maybe better, draw a histogram of `cats` score and mark the cutoffs there:

&lt;img src="images/Imbalanced-Score-Host-1.png" width="100%" /&gt;

---

Lastly, train on entire training set and evaluate on test set:


```r
mod_gbt &lt;- mod_gbt_spec %&gt;%
  fit(pets ~ ., data = bake(rec_gbt, ok_train))
pred_gbt &lt;- mod_gbt %&gt;%
  predict(new_data = bake(rec_gbt, ok_valid), type = "prob") %&gt;%
  pull(.pred_cats)
pred_gbt_class &lt;- ifelse(pred_gbt &gt; 0.17, "cats", "dogs")
true_class &lt;- ok_valid$pets
table(true_class, pred_gbt_class)
```

```
##           pred_gbt_class
## true_class cats dogs
##       cats  307  166
##       dogs  649 1607
```

```r
report_accuracy_and_auc(true_class, pred_gbt, cutoff = 0.17)
```

```
## AUC: 0.746
## ACC: 0.701
## Cats: Recall: 0.649
##       Precision: 0.321
## Dogs: Recall: 0.712
##       Precision: 0.906
```

---

### Cost aware training: Case weights

For example, in `glm()` you can simply specify a `weights` param:

&gt; when the elements of weights are positive integers *w_i*, each response *y_i* is the mean of *w_i* unit-weight observations


```r
pets_weights &lt;- rep(1, nrow(ok_train))
pets_weights[which(ok_train$pets == "cats")] &lt;- 5

mod_glm &lt;- glm(pets ~ ., data = ok_train,
*              family = "binomial", weights = pets_weights)

pred_glm &lt;- 1 - predict(mod_glm, ok_valid, type = "response")

pred_glm_class &lt;- ifelse(pred_glm &gt; 0.5, "cats", "dogs")
true_class &lt;- ok_valid$pets
```

---


```r
table(true_class, pred_glm_class)
```

```
##           pred_glm_class
## true_class cats dogs
##       cats  303  170
##       dogs  655 1601
```

```r
report_accuracy_and_auc(true_class, pred_glm)
```

```
## AUC: 0.736
## ACC: 0.698
## Cats: Recall: 0.641
##       Precision: 0.316
## Dogs: Recall: 0.71
##       Precision: 0.904
```

But this is almost equivalent to up sampling.

A more intelligent use of class weights would be something like using the `class.weights` parameter in `e1071::svm()`

---

### Cost aware training: Prior probabilities

**Small Detour: Naive Bayes**

You know Bayes' Theorem, right?

`\(P(A|B) = \frac{P(B|A)P(A)}{P(B)}\)`

or

`\(posterior = \frac{likelihood \cdot prior}{evidence}\)`

So what would be the posterior probability of class `\(C_k\)` given that we've seen observation `\(x_i\)`?

`\(P(C_k|x_i) = \frac{P(x_i|C_k)P(C_k)}{P(x_i)}\)`

---

`\(P(C_k|x_i) = \frac{P(x_i|C_k)P(C_k)}{P(x_i)}\)`

In words: the likelihood of seeing an observation like `\(x_i\)` in all class `\(C_k\)` observations, times the prior of class `\(C_k\)` observations, divided by the evidence seeing an observation like `\(x_i\)` in general.

.insight[
üí° What increases `\(P(C_k|x_i)\)`? What decreases it?
]

But if we have, say 100 predictors, each categorical with 2 levels - we'd have to pre-compute `\(2^{100}\)` possibilities for each `\(C_k\)`!

---

Enter *Naive* Bayes:

Assume that all predictors `\(X\)`  are mutually independent, conditional on the class `\(C_k\)`, and so:

`\(P(x_i|C_k) = \prod_{j = 1}^pP(x_{ij}|C_k)\)`

And so:

`\(P(C_k|x_i) = \frac{\prod P(x_{ij}|C_k)P(C_k)}{P(x_i)}\)`

And we can further expand: `\(P(x_i) = \sum_k P(x_{i}|C_k)P(C_k)\)`

.insight[
üí° How would you compute `\(P(x_{ij}|C_k)\)` when `\(x_{ij}\)` is continuous?
]

---


```r
library(naivebayes)

mod_nb &lt;- naive_bayes(pets ~ ., data = ok_train)

pred_nb &lt;- predict(mod_nb, ok_valid, type = "prob")[, "cats"]

pred_nb_class &lt;- ifelse(pred_nb &gt; 0.5, "cats", "dogs")
table(true_class, pred_nb_class)
```

```
##           pred_nb_class
## true_class cats dogs
##       cats  180  293
##       dogs  294 1962
```

```r
report_accuracy_and_auc(true_class, pred_nb)
```

```
## AUC: 0.718
## ACC: 0.785
## Cats: Recall: 0.381
##       Precision: 0.38
## Dogs: Recall: 0.87
##       Precision: 0.87
```

---

BTW, *are* our features mutually independent?


```r
ok_train %&gt;%
  filter(pets == "cats") %&gt;%
  select_if(is.numeric) %&gt;%
  cor() %&gt;%
  corrplot::corrplot()
```

&lt;img src="images/Imbalanced-Cor-Matrix-1.png" width="50%" /&gt;

---

In the context of imbalanced classes you could just give a 5 times more weight to the score of cats by specifying different prior probabilities `\(P(C_k)\)`:


```r
mod_nb &lt;- naive_bayes(pets ~ ., data = ok_train, prior = c(5, 1))

pred_nb &lt;- predict(mod_nb, ok_valid, type = "prob")[, "cats"]

pred_nb_class &lt;- ifelse(pred_nb &gt; 0.5, "cats", "dogs")
table(true_class, pred_nb_class)
```

```
##           pred_nb_class
## true_class cats dogs
##       cats  398   75
##       dogs 1251 1005
```

```r
report_accuracy_and_auc(true_class, pred_nb)
```

```
## AUC: 0.718
## ACC: 0.514
## Cats: Recall: 0.841
##       Precision: 0.241
## Dogs: Recall: 0.445
##       Precision: 0.931
```

---

### Down Sampling

Yes, down sampling the majority class, usually to make it the same amount as the minority class (but you can tune this parameter as any other).

You'd be surprised.


```r
rec_gbt &lt;- recipe(pets ~ ., data = ok_train) %&gt;%
  step_dummy(all_nominal(), -all_outcomes()) %&gt;%
* themis::step_downsample(pets, under_ratio = 1) %&gt;%
  prep(ok_train)
```

If you want to stay in the `tidymodels` framework you can download the `themis` package for extra recipes for dealing with unbalanced data.

---

.warning[
‚ö†Ô∏è Never down-sample the testing set! Look at the `skip` parameter.
]


```r
juice(rec_gbt) %&gt;% count(pets)
```

```
## # A tibble: 2 √ó 2
##   pets      n
##   &lt;fct&gt; &lt;int&gt;
## 1 cats   1624
## 2 dogs   1624
```

```r
bake(rec_gbt, ok_valid) %&gt;% count(pets)
```

```
## # A tibble: 2 √ó 2
##   pets      n
##   &lt;fct&gt; &lt;int&gt;
## 1 cats    473
## 2 dogs   2256
```

---


```r
mod_gbt &lt;- mod_gbt_spec %&gt;%
  fit(pets ~ ., data = juice(rec_gbt))
pred_gbt &lt;- mod_gbt %&gt;%
  predict(new_data = bake(rec_gbt, ok_valid), type = "prob") %&gt;%
  pull(.pred_cats)
pred_gbt_class &lt;- ifelse(pred_gbt &gt; 0.5, "cats", "dogs")

table(true_class, pred_gbt_class)
```

```
##           pred_gbt_class
## true_class cats dogs
##       cats  323  150
##       dogs  733 1523
```

```r
report_accuracy_and_auc(true_class, pred_gbt)
```

```
## AUC: 0.734
## ACC: 0.676
## Cats: Recall: 0.683
##       Precision: 0.306
## Dogs: Recall: 0.675
##       Precision: 0.91
```

---

### Up Sampling

The main disadvantage of down sampling is of course the loss of data.

Will replicating (minority class) data do any better?


```r
rec_gbt &lt;- recipe(pets ~ ., data = ok_train) %&gt;%
  step_dummy(all_nominal(), -all_outcomes()) %&gt;%
* themis::step_upsample(pets, over_ratio = 1) %&gt;%
  prep(ok_train)

mod_gbt &lt;- mod_gbt_spec %&gt;%
  fit(pets ~ ., data = juice(rec_gbt))
pred_gbt &lt;- mod_gbt %&gt;%
  predict(new_data = bake(rec_gbt, ok_valid), type = "prob") %&gt;%
  pull(.pred_cats)
pred_gbt_class &lt;- ifelse(pred_gbt &gt; 0.5, "cats", "dogs")
```

---


```r
table(true_class, pred_gbt_class)
```

```
##           pred_gbt_class
## true_class cats dogs
##       cats  262  211
##       dogs  497 1759
```

```r
report_accuracy_and_auc(true_class, pred_gbt)
```

```
## AUC: 0.739
## ACC: 0.741
## Cats: Recall: 0.554
##       Precision: 0.345
## Dogs: Recall: 0.78
##       Precision: 0.893
```

---

### SMOTE

[Chawla et. al. (2002)](https://arxiv.org/pdf/1106.1813.pdf) developed SMOTE (Synthetic Minority Over-sampling Technique) which is a up sampling technique.

The authors claim that a hybrid combination of SMOTE and regular down sampling works best, that's why SMOTE is sometimes referred to as a "hybrid" sampling algo itself.

But the up sampling does not simply replicates the minority class...

---

It synthesizes them!

&lt;img src="images/smote_algo.png" style="width: 70%" /&gt;

---


```r
n &lt;- 100
x1 &lt;- rnorm(n, 0, 1); x2 &lt;- rnorm(n, 0, 1)
t &lt;- 2 - 4 * x1 + 3 * x2
y &lt;- rbinom(n, 1, 1 / (1 + exp(-t)))

df &lt;- tibble(x1 = x1, x2 = x2, y = factor(y))
df %&gt;% count(y)
```

```
## # A tibble: 2 √ó 2
##   y         n
##   &lt;fct&gt; &lt;int&gt;
## 1 0        29
## 2 1        71
```

```r
df_smoted &lt;- recipe(y ~ ., data = df) %&gt;%
  themis::step_smote(y, over_ratio = 1) %&gt;%
  prep(df) %&gt;%
  juice()
```

---


```r
df_smoted %&gt;% count(y)
```

```
## # A tibble: 2 √ó 2
##   y         n
##   &lt;fct&gt; &lt;int&gt;
## 1 0        71
## 2 1        71
```

&lt;img src="images/SMOTE-simulation-1.png" width="100%" /&gt;

---

Let's do a hybrid of down sampling and SMOTE on our data:


```r
rec_gbt &lt;- recipe(pets ~ ., data = ok_train) %&gt;%
  step_dummy(all_nominal(), -all_outcomes()) %&gt;%
  themis::step_downsample(pets, under_ratio = 1.5) %&gt;%
  themis::step_smote(pets, over_ratio = 1) %&gt;%
  prep(ok_train)

juice(rec_gbt) %&gt;% count(pets)
```

```
## # A tibble: 2 √ó 2
##   pets      n
##   &lt;fct&gt; &lt;int&gt;
## 1 cats   2436
## 2 dogs   2436
```

```r
mod_gbt &lt;- mod_gbt_spec %&gt;%
  fit(pets ~ ., data = juice(rec_gbt))
pred_gbt &lt;- mod_gbt %&gt;%
  predict(new_data = bake(rec_gbt, ok_valid), type = "prob") %&gt;%
  pull(.pred_cats)
pred_gbt_class &lt;- ifelse(pred_gbt &gt; 0.5, "cats", "dogs")
```

---


```r
table(true_class, pred_gbt_class)
```

```
##           pred_gbt_class
## true_class cats dogs
##       cats  282  191
##       dogs  500 1756
```

```r
report_accuracy_and_auc(true_class, pred_gbt)
```

```
## AUC: 0.744
## ACC: 0.747
## Cats: Recall: 0.596
##       Precision: 0.361
## Dogs: Recall: 0.778
##       Precision: 0.902
```

---

### Other Up Sampling Methods

- ADASYN
- Borderline SMOTE
- ROSE
- Depends on data (e.g. with images it is common to perform image augmentation: flip, crop, rotate, blur it)

### Change of Framework

- Anomaly Detection

---

### One final word of wisdom

- It's Ok for a model to not know!

- The optimal choice would be for a classification model to output a *score*, rather than a class, and have the client's system interpret that score for different applications

- However, if a class output is required, consider outputting a `\(k+1\)` class: "I don't know"

- In the case of classifying cats vs. dogs people - it makes sense!

- For a two-class problem, you would have not one cutoff on the score, but two: Below cutoff 1 classify as "Dogs", above "Cats" and in the middle: "I don't know"

- As long as you make a decision regarding at least X% of the data

---

Let's see this on the `ok_valid` test set using our last SMOTEd model (but notice to tune these cutoffs you would need an extra set of untouched data!):


```r
upper &lt;- 0.65
lower &lt;- 0.35
pred_gbt_class &lt;- ifelse(pred_gbt &gt; upper, "cats",
                         ifelse(pred_gbt &lt; lower, "dogs", NA))
table(true_class, pred_gbt_class)
```

```
##           pred_gbt_class
## true_class cats dogs
##       cats  156  103
##       dogs  239 1324
```

---


```r
report_accuracy_and_auc2 &lt;- function(obs, pred, lower = 0.35, upper = 0.65) {
  pred_class &lt;- ifelse(pred &gt; upper, "cats",
                         ifelse(pred &lt; lower, "dogs", NA))
  cm &lt;- table(true_class, pred_class)
  recall_cats &lt;- cm[1, 1] / sum(cm[1,])
  recall_dogs &lt;- cm[2, 2] / sum(cm[2,])
  prec_cats &lt;- cm[1, 1] / sum(cm[,1])
  prec_dogs &lt;- cm[2, 2] / sum(cm[,2])
  acc &lt;- sum(diag(cm)) / sum(cm)
  pred_pct &lt;- sum(cm) / length(obs)
  glue::glue("Predicted: {format(pred_pct, digits = 3)}
  ACC: {format(acc, digits = 3)}
  Cats: Recall: {format(recall_cats, digits = 3)}
        Precision: {format(prec_cats, digits = 3)}
  Dogs: Recall: {format(recall_dogs, digits = 3)}
        Precision: {format(prec_dogs, digits = 3)}")
}

report_accuracy_and_auc2(true_class, pred_gbt)
```

```
## Predicted: 0.668
## ACC: 0.812
## Cats: Recall: 0.602
##       Precision: 0.395
## Dogs: Recall: 0.847
##       Precision: 0.928
```

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="../libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
